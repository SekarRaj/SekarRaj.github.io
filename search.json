[{"categories":null,"content":"Single generational concurrent garbage collection. Under 10ms max pause time.\nUsage -XX:+UseZGC\nTuning    Parameter Function     Xmx\u003csize\u003e Max heap size   XX:ConcGCThreads=\u003cnumber\u003e Number of GC threads   Xlog:gc* Basic logging   Xlog:gc** Detailed logging    Options -XX:SoftMaxHeapSize Java 13 - Soft limit of the max allocated Heap size. During memory spikes the heap size is allowed to grow beyond this threshold, however, it will be brought back during un-commit of unused memory.\nReferences  Blog-I* Blog-II OpenJDK - Wiki OpenJDK InfoQ  ","description":"","tags":["Java","Garbage Collection","ZGC"],"title":"ZGC","uri":"/posts/zgc/"},{"categories":null,"content":"Hotspott JIT compilers  C1 (client) and C2 (Server) JIT compilers  OpenJ9 -Xshareclasses\n-Xtune:virtualized\nGraal Compiler JIT - Just In Time compiler\n Compile code at runtime to optimize based on current behavior  References  Infoq-1  ","description":"","tags":["Java","JVM"],"title":"Java JIT Compiler","uri":"/posts/java_compilers/"},{"categories":null,"content":"I have used Java on and off and since the release of Java 6(or JDK 1.6) and have come to appreciate the effort and planning that went into JEPs. Despite the oracle’s license changes, the evolution of Java is quite phenominal. Java 8 brought in interesting function features and Java 9 through 11 have brought in breaking changes. On the same time depreciating features goes long way in the languages journey ahead. Developers can see warning during compilation or keep ignoring it and have tech debts pileups for the subsequent version is released. Apart from the language the JVM also has gone through lot of improvements. Few exciting projects such as Loom and Leyden are exciting features to look forward to.\nVM Functionalities To work with dynamically allocated objects the VM provides the following features,\n Interpreter Class Loading (AOT and appCDS) Garbage Collections - A look at Java’s GC Alias Analysis Biased Locking Inlining Constant folding Global value numbering  JVM Java has been undisputed champion when it comes to cross platform portability. However, this feature is achieved using the JVM which act as an intermediary between the host operating system and class files. The class file itself has no relation to the underlying architecture (x86, ARM etc) or the operating system. The JVM does this heavy lifting. The setup has definitely served it purpose, however, recent developments on containers and microservies had a different prespective. Application with low memory footprint and quick start time is of the need (Serverless).\nJIT and AOT JIT and AOT (since Java 9) are used to address these problems. The JIT does optimization at run time and it heavily affects the start up time.\nGraalVM The GraalVM is an alternative for JVM that has proven to provide significant performance improvements. If achieves this using a new JIT compiler and AOT compiled native images. GraalVM can be used instead of the JVM or we can leverage the native image build mode to achieve even smaller and faster packages. We should be vary of options that are not avilable in the native mode and adidtional considerations to get them working. For example, Reflection in Quarkus by default is not enabled in the native mode and additional annotations are required to get it working.\nWhen compiled in the native mode, the AOT compiler picks only those necessory componets that can be reaced from the main code and drops everything else. Substrate VM which has the bare essestial components required to run the program is included thereby limiting the size of the pacckage.\nGraal isn’t only for Java. It has support for numerous languages that can be used alongside with Java to complement it. It makes interopreability among these languages easier.\nGraal Java JIT that runs on top of Hotspot VM. Can be used to replace client and server compilers.\nTornadoVM Software architectures aren’t the only actor that has mode improvements. Hardware itself has evolved itself to enable faster execution. CPU’s are the only target of programmers, GPU has started playing a major role. AI and Machine learning has introduced newer models of programming. Matrix manipulation isn’t used anymore in graphics rendering alone, data science uses wide variety of mathemical operations that are faster in GPU.\nMassive paralleization is achieved by leveraging the heterogenus hardware components. Java in itself doesn’t have this capabilities. OpenCL api binding are used to hand over the computationation tasks to OpenCL which then talks with the GPU.\nReferences  CPU vs GPU TornadoVM GraalVM Infoq TornadoVM Infoq  ","description":"","tags":["Java","JVM"],"title":"Java and *VM","uri":"/posts/java_and_vm/"},{"categories":null,"content":" Matrix Reloaded\n The Keymaker Only the One can open the door. And only during that window can that door be opened.\nNiobe How do you know all this?\nThe Keymaker I know because I must know. It is my purpose. It is the reason I am here. The same reason we are all here.\n  Writing concurrent programs in a single machine is hard enough. It is difficult to reason about the correctness of the program and the system invariants. There are edge cases lurking around the corner that will never be found in any tests and lies dormant in production as well. There comes a specific set of user actions case which brings the the issue to light. Alas, figuring out what exactly happened and replicating them is quite harder.\nTraditional blocking programming model worked for the blocking syncronization mechanism. However, way of modelling system has changed significantly and reactive programming is the current fad. Creating and running a reactive programming is not a easy task on it own; reason about the control flow, error handling and other various nuances are things we give up. Nevertheless, the reactive model has proved to be effective low cost solution. One primary consideration when using event loop based model is not to have any blocking code.\nDistributed locks ups the ante further with so many variants. Networks, timers, multiple systems etc.\nTypes The Chubby reference attached in the reference sections describes locks as either fine grained(short duration) or coarse grained(long duration).\nTypical locking API provided by popular language is provided by the distributed locks. Under the hood the implementation details vary, nevertheless it is similar to locks we use in concurrent programming. Locks can be wither exclusive(monitor locks) or shared (read write locks).\nWhy to use a distributed lock? Synchronization\nCorrectness\nExpectation Availability\nReliable\nProblems  The lock master fails Client holding the lock fails Delays in n/w transmission  In an Uthopian universe the locks should work as expected. In reality things are far from perfect. First and foremost is what happens if the client holding the lock fails before giving it up. Chubby uses a lock-delay duration in whichno other client claim access to it.\nChubby Chubby refers to the shared locks as advisory locks. The locks themselves contain a lease which signfies the duration of the lock is valid for. The lock has to be renewed to keep the session active. KeepAlive requests are sent to the server to achieve this functionality.\nChubby is used for coarse-grained locks and primary use case as per the reference is name server cache and leader election.\nCurrent version leverages in memory storage and has backup mechanism set up to handle failures.\nThis blog explains the problems of distributed locking.\nDifferent implementation of distributed locks are available. Hazelcast used Fenced lock, Chubby calls it Advisory locks, Redis uses the concept of leases which is the underlying mechanism in Chubby as well.\nThe best approach is to avoid distributed locks all together. If you really need to use them choose wisely.\nReferences  Link-I Link-II Wikipedia Chubby Lock Leases  ","description":"","tags":["Distributed systems","locks"],"title":"Distributed locks","uri":"/posts/distributed_locks/"},{"categories":null,"content":"Software engineer by profession and passion. Enjoy working with distributed systems.\n","description":"","tags":null,"title":"Rajasekaran Rajaram","uri":"/about/"}]
